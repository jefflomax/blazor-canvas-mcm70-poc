@page "/mcmpoc"
@using Microsoft.Extensions.Logging
@using System.Runtime.InteropServices
@using BlazorCanvas.Runner
@using BlazorCanvas.JsInterop
@using BlazorCanvas.Emulator
@using System.Reflection
@using System.IO
@using MCMShared.Emulator
@using System.Text
@inject HttpClient Http
@inject ILogger<McmPOC> Logger
@inject AppState AppState
@*  @inject ILoggerFactory LoggerFactory *@

<div class="container">
<div class="row">

@* Tried BECanvas, but it is well out of date and provided no real value *@
@* To get the keydown event, need tabindex 0 and focus *@
<canvas
	id="@canvasId"
	width="@EmulatorWidth"
	height="@EmulatorHeight"
	tabindex="0"
	@onkeydown="CanvasOnKeypress"
	@onkeydown:preventDefault
	@onclick="CanvasOnClick"
	@onclick:preventDefault
	@ref="_canvasReference"></canvas>
</div>
<div class="row">&nbsp;</div>
<div class="row">
<canvas
	id="@printerId"
	hidden="@hidePrinter"
	width="@PrinterWidth"
	height="@PrinterHeight"
	tabindex="-1"
	@ref="_printerCanvasReference"
	></canvas>
</div>

</div>

<button
	id="startit"
	type="button"
	title="Start"
	@onclick="StartEmulator">Start Emulator</button>
<button
	id="doit"
	type="button"
	name="thebutton"
	title="Click"
	@onclick="TrySomething">Update Display</button>
<button
	id="testUnmarshalled"
	type="button"
	name="testUnmarshalled"
	title="Test Unmarshalled"
	@onclick="TestUnmarshalled">Test Unmarshalled</button>

@* Hidden image tags drawn to canvas after load *@
<img
	id="mcm"
	src="images/mcm70.png"
	hidden
	title="MCM/70"
	@onload="@(() => DrawElementToCanvas(_imgRef,canvasId,EmulatorWidth,EmulatorHeight))"
	@ref="_imgRef"/>
<img
	id="print"
	src="images/printer.png"
	hidden
	title="printer"
	@onload="@(() => DrawElementToCanvas(_printerRef,printerId,PrinterWidth,PrinterHeight))"
	@ref="_printerRef"/>

@code {
	// https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API
	// Blazor interop tests
	// https://github.com/dotnet/AspNetCore/blob/main/src/Components/test/testassets/BasicTestApp/InteropComponent.razor
	// WASM JS interop
	// This can be cast to
	// IJSInProcessRuntime (Client Side Only)
	// IJSUnmarshalledRuntime (Client Side Only, JS must handle parm conversion)
	[Inject]
	protected IJSRuntime iJsRuntime { get; set; }

	private static readonly string canvasId = "emulator";
	private static readonly string printerId = "printer";
	protected ElementReference _imgRef;
	protected ElementReference _printerRef;
	protected ElementReference _canvasReference;
	protected ElementReference _printerCanvasReference;
	private static readonly int EmulatorWidth = 932; // emulator window's width
	private static readonly int EmulatorHeight = 722;
	private static readonly int PrinterWidth = 944;
	private static readonly int PrinterHeight = 700;
	private static readonly int PrinterOpsPerDisplay = 16;
	private bool hidePrinter = true;
	private bool imagesReady = false;
	private Game _game = null;
	private int printerRedisplayCounter = 0;
	private static readonly long InstructionStepCounterThreshold = 0x40000;
	private long _instructionCountStep = InstructionStepCounterThreshold;

	[JSInvokable]
	public async ValueTask<int> GameLoop(double time)
	{
		// int component is ms since page load
		// decimals are microseconds
		//Console.WriteLine($".NET GameLoop {time}");
		if (null == _game)
			return -1;
		var instructionCountOrStop = await _game.Step();

		// We have the printer rendering (display a char, blank a block)
		// queued, try to assure there is enough work to make it sensible
		// to interop/display
		if (_game.PrinterRedisplay || printerRedisplayCounter > 0)
		{
			if (!_game.PrinterRedisplay)
			{
				if( _game.PrinterOperationOffset == 0)
				{
					printerRedisplayCounter = -1;
				}
				else
				{
					printerRedisplayCounter = PrinterOpsPerDisplay;
				}
			}

			printerRedisplayCounter++;
			_game.PrinterRedisplay = false;
			if( _game.PrinterOperationOffset > 0 && printerRedisplayCounter > PrinterOpsPerDisplay)
			{
				printerRedisplayCounter = 0;
				var _iJSUnmarshalledRuntime = iJsRuntime as IJSUnmarshalledRuntime;
				// At this time, unmarshalled invoke only takes
				// 3 parameters (plus the method name)
				_iJSUnmarshalledRuntime.InvokeUnmarshalled<byte[], UInt32[], int, int>
				(
					JSMethod.dspAplPrinterOperations,
					_game.AllFonts,
					_game.PrinterOperations,
					_game.PrinterOperationOffset
				);
				_game.ClearPrinterOperationList();
			}
#if false
			if( _game.HasRedrawList )
			{
				//Console.WriteLine($"Calling Printer Render");
				var redrawList = _game.GetRedrawList();
				var _iJSUnmarshalledRuntime = iJsRuntime as IJSUnmarshalledRuntime;
				// At this time, unmarshalled invoke only takes
				// 3 parameters (plus the method name)
				_iJSUnmarshalledRuntime.InvokeUnmarshalled<string, int[], byte[], int>
				(
					JSMethod.renderPrinterUnm,
					printerId,
					redrawList,
					_game.PrinterWindow
				);
				_game.ResetRedrawList();
			}
#endif
		}

		if( instructionCountOrStop >= _instructionCountStep)
		{
			AppState.SetInstructionCount(_instructionCountStep);
			_instructionCountStep += InstructionStepCounterThreshold;
		}

		return instructionCountOrStop;
	}

	protected override async Task OnInitializedAsync()
	{
		hidePrinter = true;

		printerRedisplayCounter = 0;

#if false
		// This works, but of course the array is in mono not JS
		// and loading embedded resources is cleaner
		Panel = await Http.GetByteArrayAsync("images/panel.data");
#endif

		// http://javascriptkeycode.com/
		KeyValues = new Dictionary<string, int>();
		KeyValues.Add("Space", 32);
		KeyValues.Add("Enter", 13);
		KeyValues.Add("Backspace", 8);
		KeyValues.Add("Equal", 0x3D);
		KeyValues.Add("Tab", 9);

		await Task.CompletedTask;
	}


	private void CanvasOnKeypress(KeyboardEventArgs ke)
	{
		//Console.WriteLine($"code {ke.Code} key {ke.Key} type {ke.Type} {ke.ToString()}");

		if( imagesReady && _game != null)
		{
			if( ke.Key.Length == 1 )
			{
				//var bytes = Encoding.ASCII.GetBytes(ke.Key);
				//if( (byte)ke.Key[0] != bytes[0])
				//{
				//	Console.WriteLine($"Conversion failed {ke.Key}");
				//}
				_game.Key((byte)ke.Key[0]);
				return;
			}

			var code = ke.Code;
			if( code.Length > 1)
			{
				if( KeyValues.TryGetValue(code, out int key))
				{
					var ascii = (byte)key;
					Console.WriteLine($"Key: {ascii}");
					_game.Key(ascii);
					return;
				}
			}
		}
	}

	private static Dictionary<string, int> KeyValues = null;

	private void CanvasOnClick(MouseEventArgs me)
	{
		// This will be needed for printer, cassette click etc

		if( imagesReady && _game!= null && _game.IsInitialized)
		{
			var button = (me.Button == 0)
				? MouseButtonSel.Left
				: (me.Button == 2)
					? MouseButtonSel.Right
					: MouseButtonSel.Unknown;

			var action = _game.Click
			(
				button,
				me.ShiftKey,
				me.OffsetX,
				me.OffsetY
			);
			switch(action)
			{
				case MouseAction.PrinterOn:
					hidePrinter = false;
					break;
				case MouseAction.PrinterOff:
					hidePrinter = true;
					break;
			}
		}
	}

	private async Task StartEmulator()
	{
		
		// call js and have it call .NET
		// on each call, get elapsed and run
		// some number of instructions

		await iJsRuntime.InvokeAsync<object>
		(
			JSMethod.startGameLoop,
			DotNetObjectReference.Create(this)
		);
		await _canvasReference.FocusAsync();
	}


	protected async Task DrawElementToCanvas
	(
		ElementReference from,
		string id,
		int width,
		int height
	)
	{
		imagesReady = true;

		await iJsRuntime.InvokeVoidAsync
		(
			JSMethod.drawImageToCanvas,
			from,
			id,
			width,
			height
		);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if(!firstRender)
		{
			return;
		}
		// Logger.LogInformation($"OnAfterRenderAsync {firstRender}");

		// Unmarshalled Interop
		// https://docs.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet?view=aspnetcore-5.0#unmarshalled-javascript-interop
		// https://docs.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet?view=aspnetcore-3.1#capture-references-to-elements
		// https://stackoverflow.com/questions/61321942/efficient-way-of-painting-html-canvas-image-by-pixels-using-blazor-client-side

		var assembly = this.GetType().Assembly;

		var initialize = LoadEmbeddedResourcesBlazorWebAssembly(assembly);

		// Ctor runs too soon to capture mono binding
		await iJsRuntime.InvokeAsync<string>(JSMethod.initialize);

		_game = new Game
		(
			initialize,
			canvasId,
			AppState,
			iJsRuntime as IJSUnmarshalledRuntime
		);

		await _game.Init(initialize);

		await _canvasReference.FocusAsync();
	}

	// Add NuGet package Microsoft.Extensions.FileProviders.Embedded
	// Set Build Action to Embedded Resource
	private InitializeWasm LoadEmbeddedResourcesBlazorWebAssembly
	(
		System.Reflection.Assembly assembly
	)
	{
		var initialize = new InitializeWasm();
		initialize.SetAssembly(assembly);
		initialize.InitAll();
		return initialize;
	}

	private async Task TestUnmarshalled()
	{
		await Task.CompletedTask;
#if false
		await iJsRuntime.InvokeAsync<int>
		(
			JSMethod.scrollTextTest,
			canvasId
		);
		// Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
		if (iJsRuntime is IJSUnmarshalledRuntime wasmJsRuntime)
		{
			var ret = wasmJsRuntime.InvokeUnmarshalled<byte[], int>
			(
				JSMethod.dspAplPrinterChars,
				_game.AllFonts
			);
		}
#endif
	}

	private async Task TrySomething()
	{
		await Task.CompletedTask;
		// unmarshalled canvas
		// https://github.com/jhwcn/BlazorUnmarshalledCanvas
		// Blazor.platform.getArrayEntryPtr
		// https://stackoverflow.com/questions/64803155/blazor-to-javascript-byte-array-interop
		// https://github.com/SteveSandersonMS/BlazorMigration/commit/b5128a7efd20b09bf8268722c2bada65b507b7da
		// https://github.com/canhorn/EventHorizon.Blazor.TypeScript.Interop.Generator/issues/34

		// BabylonJS
		// https://darnton.co.nz/2020/07/23/3d-blazor-with-babylon/
#if false
		var isWebAssembly = iJsRuntime is IJSInProcessRuntime;

		// Ctor runs too soon to capture mono binding
		await iJsRuntime.InvokeAsync<string>(JSMethod.initialize);

		// Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
		if (iJsRuntime is IJSUnmarshalledRuntime wasmJsRuntime)
		{
			await iJsRuntime.InvokeAsync<object>
			(
				"mcm70.setDotNetInstance",
				DotNetObjectReference.Create(this)
			);
		}
#endif
	}

#if false
	// Current Blazor likely does not need
	[StructLayout(LayoutKind.Explicit)]
	public struct InteropStruct
	{
		[FieldOffset(0)]
		public string CanvasId;
	}
#endif

}
