@page "/mcmpoc"
@using Microsoft.Extensions.Logging
@using System.Runtime.InteropServices
@using BlazorCanvas.Runner
@using BlazorCanvas.JsInterop
@using BlazorCanvas.Emulator
@using System.Reflection
@using System.IO
@using MCMShared.Emulator
@using System.Text
@inject HttpClient Http
@inject ILogger<McmPOC> Logger
@inject AppState AppState
@*  @inject ILoggerFactory LoggerFactory *@

<div class="container">
<div class="row">

@* Tried BECanvas, but it is well out of date and provided no real value *@
@* To get the keydown event, need tabindex 0 and focus *@
<canvas
	id="@canvasId"
	width="@EmulatorWidth"
	height="@EmulatorHeight"
	tabindex="0"
	@onkeydown="CanvasOnKeypress"
	@onkeydown:preventDefault
	@onclick="EmulatorCanvasOnClick"
	@onclick:preventDefault
	@ref="_emulatorCanvasRef"></canvas>
</div>
<div class="row">&nbsp;</div>
<div class="row">
<canvas
	id="@printerId"
	hidden="@hidePrinter"
	width="@PrinterWidth"
	height="@PrinterHeight"
	tabindex="-1"
	@onclick="PrinterCanvasOnClick"
	@onclick:preventDefault
	@ref="_printerCanvasRef"
	></canvas>
</div>

</div>

<button
	id="startit"
	type="button"
	title="Start"
	@onclick="StartEmulator">Start Emulator</button>
@*
<button
	id="doit"
	type="button"
	name="thebutton"
	title="Click"
	@onclick="TrySomething">Update Display</button>
<button
	id="testUnmarshalled"
	type="button"
	name="testUnmarshalled"
	title="Test Unmarshalled"
	@onclick="TestUnmarshalled">Test Unmarshalled</button>
*@

@* Hidden image tags drawn to canvas after load *@
<img
	id="mcm"
	src="images/panel.png"
	hidden
	title="MCM/70"
	@onload="@(()=>DrawElementToCanvas(_panelImgRef,canvasId,EmulatorWidth,EmulatorHeight))"
	@ref="_panelImgRef"/>
<img
	id="print"
	src="images/printer.png"
	hidden
	title="printer"
	@onload="@(()=>DrawElementToCanvas(_printerImgRef,printerId,PrinterWidth,PrinterHeight))"
	@ref="_printerImgRef"/>

@* Hidden images we just need to draw *@
<img id="tape_loaded_opened_img"
	src="images/tape_loaded_opened.png"
	hidden
	title="tape loaded opened"
	@onload="@(()=>DrawElementToCanvas(_tapeLoadedOpenedImgRef,ImagesWasm.TapeLoadedOpened.Str(),TapeLoadedOpenedWidth,TapeLoadedOpenedHeight))"
	@ref="_tapeLoadedOpenedImgRef"/>
<img id="@ImagesWasm.SpinLeft.Str()"
	src="images/spin_left.png"
	hidden
	title="spin left"
	@ref="_spinLeft"/>
<img id="@ImagesWasm.SpinRight.Str()"
	src="images/spin_right.png"
	hidden
	title="spin right"
	@ref="_spinRight"/>
<img id="@ImagesWasm.SpinStop.Str()"
	src="images/spin_stop.png"
	hidden
	title="spin right"
	@ref="_spinStop"/>
<img id="@ImagesWasm.TapeEmptyClosed.Str()"
	src="images/tape_empty_closed.png"
	hidden
	title="tape empty closed"
	@ref="_tapeEmptyClosed"/>
<img id="@ImagesWasm.TapeEmptyOpened.Str()"
	src="images/tape_empty_opened.png"
	hidden
	title="tape empty opened"
	@ref="_tapeEmptyOpened"/>
<img id="@ImagesWasm.TapeLoadedClosed.Str()"
	src="images/tape_loaded_closed.png"
	hidden
	title="tape loaded closed"
	@ref="_tapeLoadedClosed"/>
@* This takes advantage of drawImage taking a CanvasImageSource *@
@* So we can pass it a IMG or CANVAS and it works just the same *@
@* To display the label on the cassette, the loaded opened image *@
@* is copied from img to canvas, and the tape name is drawn on the canvas *@
<canvas
	id="@ImagesWasm.TapeLoadedOpened.Str()"
	hidden
	width="@TapeLoadedOpenedWidth"
	height="@TapeLoadedOpenedHeight"
	@ref="_tapeLoadedOpenedCanvasRef"
	></canvas>


<EditForm EditContext="EditContext" style="margin:10px;">
<div>
<label for="tapetosave">Select a tape to save</label>
<InputSelect
	id="tapetosave"
	Value="@_tapeEntry.Id"
	ValueChanged="@((int args) => {_tapeEntry.Id = args;})"
	ValueExpression="@(() => _tapeEntry.Id )">
	<option value="-1">Select Tape to Save</option>
	@foreach (var tapeEntry in AppState.TapeEntriesToSave)
	{
		<option value="@tapeEntry.Id">@tapeEntry.GetName()</option>
	}
</InputSelect>
<button disabled="@(_tapeEntry.Id == -1)"
	@onclick="@(async (e) => await this.SaveTapeOnClick(e))"
	>Save Tape</button>
</div>
<div>
<label for="tapetoload">Select a tape to load</label>
<InputFile id="tapetoload" OnChange="@UploadTape"></InputFile>
</div>
</EditForm>


@code {
	// https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API
	// Blazor interop tests
	// https://github.com/dotnet/AspNetCore/blob/main/src/Components/test/testassets/BasicTestApp/InteropComponent.razor
	// WASM JS interop
	// This can be cast to
	// IJSInProcessRuntime (Client Side Only)
	// IJSUnmarshalledRuntime (Client Side Only, JS must handle parm conversion)
	[Inject]
	protected IJSRuntime iJsRuntime { get; set; }

	private static readonly string canvasId = "emulator";
	private static readonly string printerId = "printer";
	protected ElementReference _panelImgRef;
	protected ElementReference _printerImgRef;
	protected ElementReference _emulatorCanvasRef;
	protected ElementReference _printerCanvasRef;
	protected ElementReference _tapeLoadedOpenedCanvasRef;

	protected ElementReference _spinLeft;
	protected ElementReference _spinRight;
	protected ElementReference _spinStop;
	protected ElementReference _tapeEmptyClosed;
	protected ElementReference _tapeEmptyOpened;
	protected ElementReference _tapeLoadedOpenedImgRef;
	protected ElementReference _tapeLoadedClosed;

	private static readonly int EmulatorWidth = 932; // emulator window's width
	private static readonly int EmulatorHeight = 722;
	private static readonly int PrinterWidth = 944;
	private static readonly int PrinterHeight = 700;
	private static readonly int TapeLoadedOpenedWidth = 409;
	private static readonly int TapeLoadedOpenedHeight = 256;

	private static readonly int PrinterOpsPerDisplay = 16;
	private bool hidePrinter = true;
	private bool imagesReady = false;
	private Game _game = null;
	private int printerRedisplayCounter = 0;
	private static readonly long InstructionStepCounterThreshold = 0x40000;
	private long _instructionCountStep = InstructionStepCounterThreshold;

	private EditContext EditContext;
	private TapeEntryWasm _tapeEntry = new TapeEntryWasm(-1, "none", false, false, false);


	[JSInvokable]
	public async ValueTask<int> GameLoop(double time)
	{
		// int component is ms since page load
		// decimals are microseconds
		if (null == _game)
			return -1;
		var instructionCountOrStop = await _game.Step();

		// We have the printer rendering (display a char, blank a block)
		// queued, try to assure there is enough work to make it sensible
		// to interop/display
		if (_game.PrinterRedisplay || printerRedisplayCounter > 0)
		{
			if (!_game.PrinterRedisplay)
			{
				if( _game.PrinterOperationOffset == 0)
				{
					printerRedisplayCounter = -1;
				}
				else
				{
					printerRedisplayCounter = PrinterOpsPerDisplay;
				}
			}

			printerRedisplayCounter++;
			_game.PrinterRedisplay = false;
			if( _game.PrinterOperationOffset > 0 && printerRedisplayCounter > PrinterOpsPerDisplay)
			{
				printerRedisplayCounter = 0;
				var _iJSUnmarshalledRuntime = iJsRuntime as IJSUnmarshalledRuntime;
				// At this time, unmarshalled invoke only takes
				// 3 parameters (plus the method name)
				_iJSUnmarshalledRuntime.InvokeUnmarshalled<byte[], UInt32[], int, int>
				(
					JSMethod.dspAplPrinterOperations,
					_game.AllFonts,
					_game.PrinterOperations,
					_game.PrinterOperationOffset
				);
				_game.ClearPrinterOperationList();
			}
		}

		if( instructionCountOrStop >= _instructionCountStep)
		{
			AppState.SetInstructionCount(_instructionCountStep);
			_instructionCountStep += InstructionStepCounterThreshold;
		}

		return instructionCountOrStop;
	}

	protected override async Task OnInitializedAsync()
	{
		hidePrinter = true;

		printerRedisplayCounter = 0;

		EditContext = new EditContext(_tapeEntry);

#if false
		// This works, but of course the array is in mono not JS
		// and loading embedded resources is cleaner
		Panel = await Http.GetByteArrayAsync("images/panel.data");
#endif

		// http://javascriptkeycode.com/
		KeyValues = new Dictionary<string, int>();
		KeyValues.Add("Space", 32);
		KeyValues.Add("Enter", 13);
		KeyValues.Add("Backspace", 8);
		KeyValues.Add("Equal", 0x3D);
		KeyValues.Add("Tab", 9);

		await Task.CompletedTask;
	}


	private void CanvasOnKeypress(KeyboardEventArgs ke)
	{
		if( imagesReady && _game != null)
		{
			if( ke.Key.Length == 1 )
			{
				//var bytes = Encoding.ASCII.GetBytes(ke.Key);
				_game.Key((byte)ke.Key[0]);
				return;
			}

			var code = ke.Code;
			if( code.Length > 1)
			{
				if( KeyValues.TryGetValue(code, out int key))
				{
					var ascii = (byte)key;
					Console.WriteLine($"Key: {ascii}");
					_game.Key(ascii);
					return;
				}
			}
		}
	}

	private static Dictionary<string, int> KeyValues = null;

	private void EmulatorCanvasOnClick(MouseEventArgs me)
	{
		// printer, cassette click etc

		if( imagesReady && _game!= null && _game.IsInitialized)
		{
			// TODO: Cleanup "right click"
			var button = (me.Button == 0)
				? MouseButtonSel.Left
				: (me.Button == 2)
					? MouseButtonSel.Right
					: MouseButtonSel.Unknown;

			if (me.CtrlKey || me.ShiftKey && me.Button == 0)
			{
				button = MouseButtonSel.Right;
			}

			var action = _game.EmulatorClick
			(
				button,
				me.ShiftKey,
				me.OffsetX,
				me.OffsetY
			);
			switch(action)
			{
				case MouseAction.PrinterOn:
					hidePrinter = false;
					break;
				case MouseAction.PrinterOff:
					hidePrinter = true;
					break;
			}
		}
	}

	private void PrinterCanvasOnClick(MouseEventArgs me)
	{
		if (_game != null && _game.IsInitialized)
		{
			_game.PrinterClick
			(
				me.Button == 0,
				me.OffsetX,
				me.OffsetY
			);
		}
	}

	private async Task UploadTape(InputFileChangeEventArgs e)
	{
		var ms = new MemoryStream();
		var maxAllowedSize = 1024*1024;
		await e.File.OpenReadStream(maxAllowedSize).CopyToAsync(ms);
		
		var bytes = ms.ToArray();
		var name = e.File.Name;

		if(_game != null)
		{
			_game.AddTapeEntry(name, bytes);
		}
	}

	private async Task SaveTapeOnClick(MouseEventArgs me)
	{
		await Task.CompletedTask;

		var (tapeArray, tapeName) = _game.GetTapeEntryImage(_tapeEntry.Id);

		if (iJsRuntime is IJSUnmarshalledRuntime wasmJsRuntime)
		{
			var ret = wasmJsRuntime.InvokeUnmarshalled<string, byte[], int>
			(
				JSMethod.downloadFileUnm,
				tapeName,
				tapeArray
			);
		}
	}

	private async Task StartEmulator()
	{
		// call js and have it call .NET
		// on each call, get elapsed and run
		// some number of instructions

		await iJsRuntime.InvokeAsync<object>
		(
			JSMethod.startGameLoop,
			DotNetObjectReference.Create(this)
		);
		await _emulatorCanvasRef.FocusAsync();
	}


	protected async Task DrawElementToCanvas
	(
		ElementReference from,
		string id,
		int width,
		int height
	)
	{
		imagesReady = true;

		await iJsRuntime.InvokeVoidAsync
		(
			JSMethod.drawImageToCanvas,
			from,
			id,
			width,
			height
		);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if(!firstRender)
		{
			return;
		}
		// Logger.LogInformation($"OnAfterRenderAsync {firstRender}");

		// Unmarshalled Interop
		// https://docs.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet?view=aspnetcore-5.0#unmarshalled-javascript-interop
		// https://docs.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet?view=aspnetcore-3.1#capture-references-to-elements
		// https://stackoverflow.com/questions/61321942/efficient-way-of-painting-html-canvas-image-by-pixels-using-blazor-client-side

		var assembly = this.GetType().Assembly;
		// TODO: and MCMShared assembly

		var initialize = LoadEmbeddedResourcesBlazorWebAssembly(assembly);

		// Ctor runs too soon to capture mono binding
		await iJsRuntime.InvokeAsync<string>(JSMethod.initialize);

		_game = new Game
		(
			initialize,
			canvasId,
			AppState,
			iJsRuntime as IJSUnmarshalledRuntime
		);

		await _game.Init(initialize);

		await _emulatorCanvasRef.FocusAsync();
	}

	// Add NuGet package Microsoft.Extensions.FileProviders.Embedded
	// Set Build Action to Embedded Resource
	private InitializeWasm LoadEmbeddedResourcesBlazorWebAssembly
	(
		System.Reflection.Assembly assembly
	)
	{
		var initialize = new InitializeWasm();
		initialize.SetAssembly(assembly);
		initialize.InitAll();
		return initialize;
	}

	private async Task TestUnmarshalled()
	{
		await Task.CompletedTask;
#if false
		await iJsRuntime.InvokeAsync<int>
		(
			JSMethod.scrollTextTest,
			canvasId
		);
		// Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
		if (iJsRuntime is IJSUnmarshalledRuntime wasmJsRuntime)
		{
			var ret = wasmJsRuntime.InvokeUnmarshalled<byte[], int>
			(
				JSMethod.dspAplPrinterChars,
				_game.AllFonts
			);
		}
#endif
	}

	private async Task TrySomething()
	{
		await Task.CompletedTask;
		// unmarshalled canvas
		// https://github.com/jhwcn/BlazorUnmarshalledCanvas
		// Blazor.platform.getArrayEntryPtr
		// https://stackoverflow.com/questions/64803155/blazor-to-javascript-byte-array-interop
		// https://github.com/SteveSandersonMS/BlazorMigration/commit/b5128a7efd20b09bf8268722c2bada65b507b7da
		// https://github.com/canhorn/EventHorizon.Blazor.TypeScript.Interop.Generator/issues/34

		// BabylonJS
		// https://darnton.co.nz/2020/07/23/3d-blazor-with-babylon/
#if false
		var isWebAssembly = iJsRuntime is IJSInProcessRuntime;

		// Ctor runs too soon to capture mono binding
		await iJsRuntime.InvokeAsync<string>(JSMethod.initialize);

		// Check if the IJSRuntime is the WebAssembly implementation of the JSRuntime
		if (iJsRuntime is IJSUnmarshalledRuntime wasmJsRuntime)
		{
			await iJsRuntime.InvokeAsync<object>
			(
				"mcm70.setDotNetInstance",
				DotNetObjectReference.Create(this)
			);
		}
#endif
	}

#if false
	// Current Blazor likely does not need
	[StructLayout(LayoutKind.Explicit)]
	public struct InteropStruct
	{
		[FieldOffset(0)]
		public string CanvasId;
	}
#endif

}
